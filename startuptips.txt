mkdir -p flaskfile/{templates,static}


APP.logger.info('testing info log', request)
return 'Check Console'










        # fstring = f.read()
        # csv_dicts = [{k: v for k, v in row.items()} for row in
                     # csv.DictReader(fstring.splitlines(), skipinitialspace=True)]


    # graph_dir = os.path.join(folderpath, 'graphs')
    # os.makedirs(graph_dir, exists_ok=True)


Background correction work:

    dataconv = copy.deepcopy(data)

                # find where the second rise begins in the first derivative data
                Ie[ip, i] = xstart  # start below the second peak in the smoothed first derivative,
                while stillIncreasing(int(Ie[ip, i]), derivativeline):
                    Ie[ip, i] -= -1

                startofinflection[ip, i] = getmin(time, timediff[int(Ie[ip, i])])

                # find where the first derivative stops increasing -> to fit data to the first rise
                Ie[ip, i] = int(peaklocations[k, i])
                if Ie[ip, i] > 2:
                    Ie[ip, i] = int(Ie[ip, i] - np.floor(peakwidth[k] / 2))
                    while stillIncreasing(int(Ie[ip, i]), derivativeline[:]) and int(Ie[ip, i]) >= 2:
                        Ie[ip, i] = Ie[ip, i] - 1
                        if Ie[ip, i] == 2:
                            break

                # find where the first rise begins, index in the data
                startofinflection[ip, i] = getmin(time, timediff[int(Ie[ip, i])])




########## background correct data
    correcteddata = [0] * wellcount
    for well in range(wellcount):
        if startofinflection[0, well] < 3:
            correcteddata[well] = dataconv[0, well]
        elif startofinflection[0, well] < 10:
            correcteddata[well] = dataconv[1, well]
        else:
            correcteddata[well] = np.nanmean([dataconv[int(startofinflection[0, well]) - i, well] for i in range(2)])
        dataconv[:, well] = [i - correcteddata[well] for i in data[:, well]]







###############write code
    workbook = xlsxwriter.Workbook(infofile[:-8] + '_AnalysisOutputtest.xlsx')

    label = ['Inflection 1 (min)', 'Inflection 2 (min)', 'Inflection 3 (min)', 'Inflection 4 (min)']
    label.extend(['RFU of Inflection 1 (RFU)', 'RFU of Inflection 2 (RFU)', 'RFU of Inflection 3 (RFU)',
                  'RFU of Inflection 4 (RFU)'])
    label.extend(['Diff of Inf 1 to Inf 3 (min)', 'Diff of Inf 2 to Inf 4 (min)'])
    label.extend(['Max derivative of first phase (RFU/min)', 'Max derivative of second phase (RFU/min)'])

    worksheet = workbook.add_worksheet('Inflections')
    col = 0
    for j in range(wellcount):  # each experiment
        r = int(individualresults[j, 1] - 1) * (numberofvariables + 2)
        if individualresults[j, 1] != individualresults[j - 1, 1] and j > 0:  # reset to left for each experiment
            col = 0
        col += 1
        for var in range(numberofvariables):
            if var == 0:  # Well labels only need to be written in first row once
                worksheet.write(r, col, header[j])
            r += 1
            if col == 1:  # Variable labels only need to be written in first column once
                worksheet.write(r, 0, label[var])
            worksheet.write(r, col, individualresults[j, var + 2])  # Variable value

    width = np.max([len(i) for i in label])
    worksheet.set_column(0, 0, width)

    label = ['Inflection 1 avg', 'Inflection 1 std', 'Inflection 2 avg', 'Inflection 2 std']
    label.extend(['Inflection 3 avg', 'Inflection 3 std', 'Inflection 4 avg', 'Inflection 4 std'])
    label.extend(['RFU 1 avg', 'RFU 1 std', 'RFU 2 avg', 'RFU 2 std'])
    label.extend(['RFU 3 avg', 'RFU 3 std', 'RFU 4 avg', 'RFU 4 std'])
    label.extend(['Diff 1 to 3 avg', 'Diff 1 to 3 std', 'Diff 2 to 4 avg', 'Diff 2 to 4 std'])
    label.extend(['Max slope phase 1 (avg RFU/min)', 'Max slope phase 1 (std RFU/min)'])
    label.extend(['Max slope phase 2 (std RFU/min)', 'Max phase slope 2 (std RFU/min)'])

    worksheet = workbook.add_worksheet('Mean Inflections')
    col = 0
    for trip in triplicates:  # each triplicate
        j = np.where(triplicateresult[:, 0] == trip)[0][0]
        r = int(triplicateresult[j, 1] - 1) * (numberofvariables * 2 + 2)
        if triplicateresult[j, 1] != triplicateresult[j - 1, 1] and j > 0:
            col = 0
        col += 1

        for var in range(numberofvariables * 2):
            if var == 0:  # Well labels only need to be written in first row once
                worksheet.write(r, col, triplicateheaders[j])
            r += 1
            if col == 1:  # Variable labels only need to be written in first column once
                worksheet.write(r, col - 1, label[var])
            worksheet.write(r, col, triplicateresult[j, var + 2])  # Variable value
    width = np.max([len(i) for i in label])
    worksheet.set_column(0, 0, width)

    # workbook = writeSheet(workbook, 'Corr RFU', header, time, dataconv)
    workbook = writeSheet(workbook, 'Raw RFU', header, time, data)
    dataaverages = averagetriplicates(data, triplicates, individualresults[:, 0])
    workbook = writeSheet(workbook, 'Raw RFU avgs', triplicateheaders, time, dataaverages)

    workbook.close()
